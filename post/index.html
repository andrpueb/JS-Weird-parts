<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <link rel="stylesheet" href="./style.css">
  <link href="https://fonts.googleapis.com/css?family=Arsenal" rel="stylesheet">
  <link rel="stylesheet" href="http:////cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/ocean.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  <title>JS weird parts</title>
</head>

<body>
  <h1>JavaScript - The weird parts</h1>
  <section>
    <h2>Syntax Parcers - Execution Context - Lexical Environments</h2>
    <div>
      <h3>Syntax Parcers</h3>
      <p>Es un programa que lee el código que escribimos, entiende lo que hace y revisa si la gramatica es valida, se llama compilador y convierte el código en un código que la máquina pueda entender</p>
    </div>
    <div>
      <h3>Lexical Environment</h3>
      <p>El lugar fisico en donde se encuentra el códgio que escribimos. Sirve para saber el uso de la memoria y lo que ese código puede usar dependiendo de lo que lo rodee</p>
    </div>
    <div>
      <h3>Execution Context</h3>
      <p>Es una envoltura que maneja el código que se está ejecutando, Hay muchos lexical environments, el que se está ejecutando es manejado a través del execution context y puede contener muchas mas cosas de las que están escritas en nuestro código.</p>
    </div>
  </section>
  <section>
    <h2>Name/Value pairs and Objects</h2>
    <div>
      <h3>Name/Value pairs</h3>
      <p>Un Nombre que apunta o mapea a un unico valor. <br>El nombre puede ser difinido mas de una vez pero, solo puede tener un valor en cualquier contexo dado.</p>
      <p>El valor pueden ser mas parejas nombre/valor.</p>
      <code>ciudad = 'bogota'</code>
      <p>nombre: ciudad <br> valor: bogota</p>
    </div>
    <div>
      <h3>Objeto</h3>
      <p>Un objeto es simplemente una colección de parejas nombre/valor, por ejemplo:</p>
      <img class="code-img" src="./media/object.png" alt="">
    </div>
  </section>
  <section>
    <h2>The Global environment and The global object </h2>
    <p>Cuando hablamos de global, hablamos de algo que es accesible desde cualquier parte de nuestro código y siempre hay dos cosas que se creán automaticamente para nosotros en el contexto global que son un <b>Global Object</b> y <b>this</b>, estos dos
      objetos son creados para nosotros por el engine de JavaScript.</p>
    <p>Si queremos ver esto, lo que podemos hacer es simplemente abrir en nuestro explorador un archivo html que no incluya ningúna tipo de JS asociado o podemos vincular un archivo .js pero que no contenga nada, si nos vamos a dev tools de nuestro explorador
      y en la consola escribimos <code>window</code> o <code>this</code> lo que vamos a ver es lo siguiente:</p>
    <img class="code-img" src="./media/window_this.png" alt="">
    <p>Lo que nos devuelve la consola es un objeto global llamado <code>window</code> en ambos casos, tanto con <b>this</b> como con <b>window</b>, esto solo sucede porque estamos en el contexto global, en donde <b>window</b> es básicamente el contexto global
      y <b>this</b> se refiere al contexto en donde lo estamos llamando que en este caso son lo mismo.</p>
    <p>El concepto global significa sencillamente que no estamos dentro de ninguna función. </p>
  </section>
  <section>
    <h2>The Execution Context: Creation and 'Hoisting'</h2>
    <p>Que pasa cuando en JS declaramos una variable y una función y logueamos la variable y llamamos la función? de esta forma:</p>
    <img class="code-img" src="./media/creation_hoisting_one.png" alt="">
    <p>Si lo hacemos de esta manera lo que pensamos es que vamos a ver en la consola primero el valor de <b>a</b> y después de el valor de <b>b</b> y eso es efectivamente lo que veremos:</p>
    <img class="code-img" src="./media/creation_hoisting_two.png" alt="">
    <p>Ahora la pregunta es, que pasa si movemos hacia arriba el llamado a la variable y a la función?</p>
    <img class="code-img" src="./media/creation_hoisting_three.png" alt="">
    <p>Si ejecutamos este código en la consola del explorador vamos a ver lo siguiente:</p>
    <img class="code-img" src="./media/creation_hoisting_four.png" alt="">
    <p>Que pasó?? Antes tanto el llamado a la variable como a la función devolvían los valores correctos pero ahora la variable nos devuelvle el valor de <b>undefined</b> y la función el valor correcto.</p>
    <p>Se dice que al momento de ejecutarse el código sucede algo que llaman 'Hoisting' y que lo que supuestamente sucede es que la declaración de variables y de funciones son movidas hacia la parte mas alta del código, <b>pero</b> si esto realmente sucediera,
      por qué el valor devuelto a nuestra variable es <b>undefined</b> mientras que a nuestra función si es el correcto?</p>
    <p>Lo que realmente pasa es que la creación de un <b>Execution Context</b> sucede en dos fases, una es la <b>Fase de Creación</b> que es en donde sucede lo siguiente:</p>
    <img class="img-custom" src="./media/creation_hoisting_phase_one.png" alt="">
    <p>Durante ese proceso de prepara el espacio en memoria para las funciones y las variables, que es lo que realmente es hoisting, se toma unicamente lo que está antes de una asignación <b>=</b> por esta razón es que en el caso de la variable se toma solamente
      el nombre <b>var a</b> y la función se toma completa porque no hay asignación. Al tomar el lado izquierdo de la asignación el engine le asigna un marcador de posición o placeholder con el valor de 'undefined' el cual es redifinido en la fase de
      ejecución si la variable es invocada después de habersele asignado un valor. <mark>Siempre es mejor idea invocar variables y funciones después de haber sido declaradas.</mark></p>
  </section>
  <section>
    <h2>JavaScript and 'Undefined'</h2>
    <p>Como vimos antes, undefined es un valor que les da el engine de JS a las variables en la fase de creación, así todas las variables tengan un valor asignado siempre se les dará el valor de undefined en la primera fase, ya después en la fase de ejecuciónm,
      el valor de la variable será actualizado si al momento de que esa variable sea usada su valor ya haya sido asignado.</p>
    <p>En caso </p>
  </section>
  <section>
    <h2>The Execution Context - Code Execution</h2>
    <img class="img-custom" src="./media/creation_hoisting_phase_two.png" alt="">
    <p>La fase dos es basicamente la ejecución por parte del engine de linea por linea de nuestro código, ya despues de haber sido crerado el objecto global, this y el environment externo.</p>
  </section>
  <section>
    <h2>Single Threaded, Synchronous Execution</h2>
    <h3>Single Threader</h3>
    <p>Un comando se ejecuta a la vez, no mas de uno a la vez.</p>
    <h3>Asynchronous</h3>
    <p>Muy parecido al anterior, un comando a la vez! pero además en orden de acuerdo a como van apareciendo.</p>
  </section>
  <section>
    <h2>Function Invocation And The Execution Stack</h2>
    <h3>Invocation</h3>
    <p>Invocar significa llamar una función, hacer que se ejecute y lo hacemos con el nombre de la función y parenthesis: <code>a();</code>, pero que pasa cuando invocamos una función? pensemos en el siguiente ejemplo:</p>
    <img src="./media/execution_stack_one.png" alt="">
    <p>Cómo sabemos, JS es Synchronous y Sinlge Threaded y por lo tanto ejecuta una linea por vez y en orden, y sabemos que un contexto de ejecución consta de dos fases, la de creación y la de ejecución. </p>
    <p>En este ejemplo en la primera fase la función <b>a</b> y la función <b>b</b> serán guardadas en memoria y en la segunda fase se ejecutará el código linea por linea.</p>
    <ol>
      <li>
        <p>Lo primero en ejecutarse será la función <b>a</b> ya que es la primera en ser invocada <code>a();</code> en el contexto global, como es una función, para su ejecución se crea un nuevo contexto de ejecución (Execution Context) que es apilado sobre
          el contexto global, esto se denomina <b>Pila de Ejecución (Execution Stack)</b>:</p>
        <img class="img-custom" src="./media/execution_stack_two.png" alt="">
        <p>Cada contexto de ejecución tiene la fase de creració y de eejecució y además tiene su propio espacio para la creación de variables y de funciones.</p>
      </li>
      <li>
        <p>Lo siguiente en suceder es la invocación de la función <b>b</b> <code>b();</code> que sucede dentro de la función <b>a</b> y otro contexto de ejecución es creado y apilado sobre el anterior:</p>
        <img class="img-custom" src="./media/execution_stack_three.png" alt="">
        <p>Al ejecutarse el contenido de <b>b</b> el contexto de ejecución es movido fuera del stack y se ejecuta el siguiente hacia abajo que en nuestro caso será <b>a</b>.</p>
      </li>
    </ol>
    <p>Los contextos de ejecución se van procesando de arriba hacia abajo</p>
  </section>
  <section>
    <h2>Function, Context, And Variable Environments</h2>
    <p>Cuando creamos una variable debemos tener claro que pasa en cada uno de los contextos de ejecución, como ya vimos, cada función crea un contexto y si las variables son declaradas dentro de un contexto, el valor de la variable solo se verá afectado
      si es modificado dentro de ese mismo contexto, si hay otra variable con un mismo nombre declarada dentro de otro contexto, su valor no se ve afectado si su nombre cambia en un contexto diferente, veamos un ejemplo claro:</p>
    <img class="img-custom" src="./media/variable_environment_one.png" alt="">
    <ol>
      <li>La primera variable es declarada en el contexto global <code>var myVar = 1;</code></li>
      <li>La función <b>a</b> es invocada <code>a();</code> y dentro de su contexto de ejecución se declara una nueva variable <b>myVar</b> <code>var myVar = 2;</code></li>
      <li>dentro de la función se invoca la función <b>b</b> y dentro de su contexto de ejecución se declara una nueva variable con el mismo nombre <b>myVar</b> <code>var myVar;</code> pero no se le da ningún valor</li>
    </ol>
    <p>Que vemos en la consola cuando ejecutamos este código:</p>
    <img class="img-custom" src="./media/variable_environment_two.png" alt="">
    <p>A pesar de que las variables hayan sido declaradas multiples veces con un mismo nombre, el valor con el que fueron declaradas se mantiene porque fueron creradas en ambientes (environments) distintosx</p>
  </section>
  <section>
    <h2>The Scope Chain</h2>
    <p>Cuando hablamos de <b>Scope</b> nos referimos al alcance que tienen cada una de las funciones o variables que declaramos en nuetsros código, como vimos antes, cada una de las funciones creran un contexto de ejecución propio y que si una variable con
      un mismo nombre es declarada dentro de diferentes contextos de ejecución su valor solo dependerá de los cambios que se hagan dentro de su propio contexto</p>
    <p>Tambien vimos que cuando un contexto de ejecución es creado una de las cosas que también es creada para nuestro uso es el <b>Outer Environment</b> o entorno externo, esto es sencillamente una referencia a su enteorno externo mas próximo, veamos: </p>
    <img src="./media/outer_environment_one.png" alt="">
    <p>En este ejemplo tenemos dos funciones declaradas y declaramos la variable <b>myVar</b> en el contexto global y dentro del contexto de la función <b>a</b>. Dentro de la función <b>b</b> buscamos imprimir en consola el valor de <b>myVar</b> que valor
      veremos?
    </p>
    <p>Aquí debemos tener en cuenta lo que se denomina como <b>Lexical Environment</b> que se refiere al entorno dependiendo de donde ha sido la función o la variable fisicamente declarada, y como fisico nos referimos a su posición de acuerdo al resto de
      declaraciones, el lugar en que hayamos escrito nuestra función.</p>
    <img class="img-custom" src="./media/outer_environment_two.png" alt="">
    <ol>
      <li>En el código que escribimos tanto <b>a</b> como <b>b</b> se encuentran al mismo nivel, las dos declaradas sobre el contexto global</li>
      <li>La variable <b>myVar</b> es declarada sobre el contexto global y dentro del contexto de la función <b>a</b>.</li>
      <li>la función <b>b</b> es invocada dentro de la función <b>a</b></li>
      <li>Aunque la función <b>b</b> sea invocada dentro de <b>a</b>, la función <b>b</b> fué declarada sobre el contexto global, al no encontrar la variable <b>myVar</b>dentro de su contexto entonces va a buscar en su entorno externo mas cercano que en este
        caso es el contexto global en donde si encuentra la variable que busca <code>var myVar = 1;</code> y por lo tanto <b>1</b> es el valor que veremos en la consola.</li>
    </ol>
    <p>Cuando una función es invocada siempre va a tratar de buscar el valor de sus variables en su contexto de ejecució primero, si no la encuentra se va a iniciar un proceso conocido como <b>Scopr Chain</b> que es basicamente la busqueda de la variable
      a través de todos los entornos externos que sean directamente vinculados:</p>
    <img class="img-custom" src="./media/outer_environment_three.png" alt="">
  </section>
  <section>
    <h2>Scope, ES6, and let</h2>
    <h3>Scope</h3>
    <p>Es en definitiva <b>En donde la variables se encuentra disponible en nuestro código</b> dependiendo si es la misma variable o una copia nueva.</p>
    <h3>ES6</h3>
    <p>La última version de JavaScript, ECMASCRIPT 6 o ECMASCRIPT 2016</p>
    <h4>let</h4>
    <p><code>let</code> es una nueva forma diferente de declarar variables, <b>let</b> permite usar <b>block scoping</b> vamos a hablar de ella mas adelante.</p>
  </section>
  <section>
    <h2>Asynchronous Callbacks</h2>
    <p>Como ya vimos JS es un lenguaje que se ejecuta de forma sincronica (Syncrhonous) lo que significa que el código se ejecuta linea por linea, en JS no es posible ejecutar varias lineas de código a la vez, esto se conoce como <b>single threaded</b></p>
    <p>Como también ya sabemos cada función va creando un <b>Execution Stack</b> que es el apilamiento de contextos de ejecución, pues bueno, lo que sucede es que el JavaScript Engine tiene algo llamado <b>Event Queue</b> o <b>Cola de eventos</b>. La cola
      de eventos es una fila de eventos que se va creando y que el engine va ejecutando de acuerdo a como vaya terminando cada uno de los contextos de ejecución que tiene pendientes, tan pronto como termine un <b>Execution Stack</b> el engine se dirije
      al <b>Event Queue</b> y ejecuta le siguiente tarea pendiente, veamos en la siguinete imagen:</p>
    <img class="img-custom" src="./media/Synchronous_one.png" alt="">
    <p>Aquí tenemos una pila de contextos ejecutandose, cuando esta pila se haya completado el engine seguirá con la siguiente tarea o evento que en este caso es un click y ejecutará su contexto. <b>No es posible que JavaScript corra o ejecute mas de un contexto de ejecución al tiempo</b>      lo vamos a comprobar con el siguiente ejercicio:</p>
    <img class="img-custom" src="./media/Synchronous_two.png" alt="">
    <p>Cuando corramos este código en la consola y hagamos click sobre la página, lo que vamos a ver es que en la consola no va a imprimirse nada sino hasta que la función <b>waitThreeSeconds</b> termine de ejecutarse a los tres segundos, osea, hasta que
      su execution stack no sea completamente ejecutado, durante los 3 segundos los eventos <b>click</b> van a ser puestos en cola para ser ejecutados cuando el engine se desocupe.</p>
    <img class="img-custom" src="./media/Synchronous_three.png" alt="">
    <p>A pesar de que hagamos click muchas veces sobre la página, estos clicks no van a ser impresos en consola sino hasta después de que los 3 segundos hayan pasado.</p>
  </section>
  <section>
    <h2>Types and JavaScript</h2>
    <p>Si hemos venido de otro tipo de lenguajes de programación, vamos a ver que en JS los tipos de variable de declaran de una forma diferente.</p>
    <h3>Dynamic Typing</h3>
    <p>En JS no le tenemos que decir al engine que tipo de información va a contener la variable, el engine s eencarga de decifrar el tipo de información mientras el código se va ejecutando.</p>
  </section>
  <section>
    <h2>Primitive Type</h2>
    <p>Cómo sabemos JS usa un método que se llama <b>Dynamic Typing</b> y por lo tanto no tenemos que definir el tipo de informació de cada variable sino que el engine lo decifra por si solo, esto no quita que hayan diferentes tipos de datos o información
      y este tipo de datos se denominan <b>Primitive Types</b>.</p>
    <h3>Primitive Types</h3>
    <p>Son tipos de datis que representan un solo valor, mas facil, todo lo que no es un objeto pues un objeto es una colección que puede ser diferentes tipos de información.</p>
    <ol>
      <li><b>UNDEFINED:</b> Es inexistencia, una variable que no existe. <b>No debemos asignar este valor a ninguna variable, es solo para uso del engine al momento de crear la memoria para nuestro código.</b></li>
      <li><b>NULL:</b> También reperesenta inexistencia, este si lo podemos usar para definir una variable igual a nada <code>var a = null;</code></li>
      <li><b>BOOLEAN:</b> Puede ser o <b>true</b> o <b>false</b> solo uno de los dos <code>var a = true;</code></li>
      <li><b>NUMBER:</b> En JS solo hay un tipo numerico y siempre es un <b>floating point number</b> o número decimal, aunque se puede volver entero o <b>integer</b> es realmente un decimal.</li>
      <li><b>STRING:</b> Es una sequencia de caracteres que se encuentran entre comillas simples <b>' '</b> o dobles <b>" "</b>.</li>
      <li><b>SYMBOL:</b> Es usado en ES6, hablaremos de el en otro momento.</li>
    </ol>
  </section>
  <section>
    <h2>Operators</h2>
    <p>Un operador es una función que es sintacticamente escrita de manera distinta. Los operadores generalmente reciben un parametro y devuelven dos</p>
    <p>Cuando usamos un operador <b>+, -, >, <, etc</b> lo que realmente estamos usando es una función que ha sido pre escrita para que nosotros podamos usar los operadores más rapidamente, en lugar de tener por ejemplo que escribir: <code> function suma(a, b){return a + b}</code>      lo que hacemos es <code>a + b</code>, lo mismo sucede con todos los operadores</p>
  </section>
  <section>
    <h2>Operator Precedence and Associativity</h2>
    <h3>Operator Precedence</h3>
    <p>Es simplemente que funcion de operador es llamada de primero, <b>las funciones son llamadas en order de precedencia</b>, la precedencia mas alta gana.</p>
    <h3>Operator Associativity</h3>
    <p>La asociatividad determina la dirección en la que operadores con la misma precedencia son evaluados.</p>
    <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">Ver documento en MDN</a></p>
    <p>Este documento es importante porque nos muestra los valores de precedencia que tiene cada operador y además nos muestra la asociatividad o dirección en que operdaores iguales son evaluados.</p>
    <p>Qeu pasa si tenemos lo siguiente:</p>
    <img class="img-custom" src="./media/Operator_Precedence.png" alt="">
    <p>Si alguna vez en nuestras vidas tuvimos clase de matematicas, sabemos que la multiplicación va primero y por lo tanto el resultado es 15. Si vemos la tabla de precedencia veremos que el valor que tiene la multiplicación es 14 mientras que suma tiene
      un valor de precedencia de 13, los mayores ganan!</p>
    <p>Y ahora que pasa si tenemos oo siguiente:</p>
    <img class="img-custom" src="./media/Operator_Precedence_two.png" alt="">
    <p>Que vamos a ver en la consola?</p>
    <p>Para saberlo tenemos que ver el sentido de asociatividad que tiene la igualdad <b>=</b>, en la tabla vemos que es de <b>derecha a izquierda</b> lo que quiere decir que primero se definen los de la derecha que en nuestro caso será <code> b = c </code>      o en otras palabras, <b>b</b> es igual a <b>c</b>, <b>c</b> es 4 y por lo tanto <b>b</b> será 4. <b>a</b> será lo que es <b>b</b> y como en este punto <b>b</b> ya es 4, entonces <b>a</b> es también igual a 4.</p>
  </section>
  <section>
    <h2>Coercion</h2>
    <p>En JS coercer u obligar se refiere la acción que genera el engine en algunos momentos sobre algunos valores, lo que hace JS es convertir su tipo de valor a otro tipo de valor. <br> Por ejemlpo tenemos lo siguiente <code>var a = 1 + '5'</code> como
      vemos uno de los valores es declarado cómo un número y el otro como un string, cuando mostramos el resultado en la consola veremos un <code>12</code>. Esto sucede porque el otro es un string y por lo tanto el engine convertirá el número en un string
      para buscar darle un resultado coherente al usuario.</p>
  </section>
  <section>
    <h2>Comparison Operator - Operadores de comparasión</h2>
    <p>Muchas veces usamos operadores de comparación y aunque creemos que tenemos claro el resultado que nos va a arrojar en algunas ocasiones nos podemos sorprender (a mi me sucedió) para comenzar, veamos el siguiente ejemplo: <code>1 &lt; 2 &lt; 3</code>      en engine en este ejemplo nos va a arrojar <code>true</code> lo que en realidad tiene sentido porque 1 es menor a dos y dos es menor que 3.</p>
    <p>Ahora intentemos lo siguiente: <code> 3 &gt; 2 &gt; 1</code> que vemos en la consola??</p>
    <img class="img-custom" src="./media/coercion_one.png" alt="">
    <p>Vemos <b>false</b> por que? si 3 es mayor que 2 y 2 es mayor que 1? <br>Si vamos a mirar el documento que nos habla sobre la precedencia en los operadores <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">aquí el link de nuevo</a>      vemos que el operador <code>&gt;</code> es analizado por el engine de izquierda a derecha, entonces que pasa?</p>
    <img class="img_custom" src="./media/coercion_two.png" alt=""><br>
    <p>Pues lo que sucede es que primero se evalúa la primera expresión <code>3 &gt; 2</code> que dá como resultado el boolean <code>true</code> quedando la expresión <code>true &gt; 1</code> por ser evaluada. Pero que pasa aquí? pues bueno, como sabemos
      el engine va hacer lo posible por dar un resultado coherente y en este caso va a transformar el valor del boolean true por el número 1 dejando la siguiente expresión <code>1 &gt; 1</code> y como sabemos 1 <b>no</b> es mayor que 1 y el resultado
      va a ser <b>false</b>.</p>
    <p>Así como el engine cambia el valor de true a 1, hay muchas otras combinaciones y cambios que pueden terminar dando un reultado diferente, aquí no vamos a profundizar en este punto pero si es importante tener claro que el operador <code>==</code> nos
      resuelve igualdad por ejemplo: <code>3 == '3' = true</code> en caso de que uno de los dos valores sea de un 'tipo' diferente entonces será cambiado (la mayoría de las veces) para que la operación tenga un resultado.</p>
    <p>Por otro lado tenemos el operador <code>===</code> que nos resuelve una <b>igualdad estricta</b> por lo tanto <code> 3 === '3' = false</code> y <code>3 === 3 = true</code> ningún valor es cambiado, solo se devuelve true si es una igualdad completamente
      estricta.
    </p>
  </section>
  <section>
    <h2>Booleans Existence</h2>
    <p>Es importante saber que la falta de existencia como <b>undefined, null o ""</b> son evaluados como booleans <b>false</b> sabiendo esto podemos usar esta evaluación a nuestro favor, siempre que usamos las declaraciones condicionales (conditional statements)
      <b>if</b> lo que se encuentra dentro de la condición siempre va a buscar ser evaluado como un boolean, por ejemplo:</p>
    <img class="img_custom" src="./media/existence_boolean_one.png" alt="./media/existence_boolean_one.png">
    <p>Cuando ejecutamos esta declaración en la consola nada va a ser impreso, por que? porque a la variable <b>a</b> no se le ha dado ningún valor y como sabemos, en la fase de creación a todas las variables se les asigna por el engine el valor de <b>undefined</b>      el cual al ser evaluado como boolean nos da el valor de <b>false</b>.</p>
    <h3>0 también es false</h3>
    <p>Es importante tener en cuenta que el valor <b>0</b> también es evaluado como falso por el engine y 0 no tiene que significar inexistencia, eso depende de nuestro código y que queremos que haga, entonces is por alguna razón el valor de la variable
      llega a tener el valor de 0 pero lo que queremos es evaluar su existencia (undefined, null, '') es posible que tengamos un resultado diferente al que esperamos, en este casos podríamos ajustar mejor la condición de esta manera: <code>(a || a === 0)</code>,
      así si la primera condicion es inexistente incluyendo 0, será evaluada como false, pero la segunda será true porque <b>a</b> será en nuestro ejemplo igual a <b>0</b> por lo tanto la condición será evaluada como true <code>false||true</code> da como
      resultado <code>true</code>.</p>
  </section>
  <section>
    <h2>Default Values</h2>
    <p>Una forma interesante de asignar valores por defecto es mediante el uso de <code>||</code> por ejemplo podemos decir <code>nombre = nombre || 'no hay nombre'</code>, como sabemos el operador <b>or</b> evalúa las condiciones buscando convertirlas en
      booleanos, así el primoer que resulte <b>true</b> será el valor que se asignará, en este caso si <b>nombre</b> resulta falso ej: <b>undefined, null, false o 0</b> entonces la segunda será evaluada, el engine la convertirá u obligará a ser booleano
      y como la segunda condición es un string no vacío, entonces será <b>true</b> y el valor que se le asignará a la variable <b>nombre</b> será <em>no hay nombre</em>.</p>
  </section>
  <section>
    <h2>FRAMEWORK ASIDE:Default Values</h2>
    <p>Es muy probable que en algún momento queramos usar diferentes frameworks o librerias en un mismo proyecto y también es posible que estas usen el contexto global para declarar variable y podría suceder que la declaración de variables colisione, en
      estos caso es muy probable que veamos cosas así: <code>window.nombreDeVariable = window.nombreDeVariable || 'otro valor'</code> lo que se logra con esta verificación es que no se sobreescriban valores que ya existen o variables que ya están declaradas
      y definidas, como ya vimos esto significa: <em>Si la variable ya existe entonces no la modifique <b>pero si no existe</b> cambiela por este nuevo valor que le estoy dando.</em></p>
  </section>
  <section>
    <h2>Objects and Functions</h2>
    <p>Como ya vimos antes los objetos se pueden componer de variables primitivas como numeros o string, también puede contener otros objetos o también pueden contener método que en realidad son funciones que devuelven algún valor.</p>
    <h3>Cómo creamos lo objetos?</h3>
    <p>En realidad podemos crerar un objeto de diferentes formas, resumidas son las siguientes:</p>
    <ul>
      <li>Object literal: Es a través del uso de los corchetes o curly braces <br>
        <code>var carro = { marca: 'Ferrari, modelo: 1989, modelo: Testarossa' }</code>
      </li>
      <li>También lo podemos hacer a través del constructor Object() <br>
        <code>var carro = new Object()</code>
      </li>
      <li>Podemos usar una función constructora <br>
        <code>var Obj = function(name){ <br>
          this.name = name
        } <br>
        var miCarro = new Obj('Mi Nave');
      </code>
      </li>
    </ul>
    <h3>Acceder a los objetos y agregar propiedades</h3>
    <p>Cómo vimos antes, con lo corchetes o curly braces podemos declarar un objeto y además decalarar propiedades al mismo tiempo, agregar propiedades se puede hacer de multiples formas así como acceder a ellas</p>
    <ul>
      <li> <b>Con parentesis cuadrados [ ]</b> - tenemos el objeto carro ya declarado y declaramos la propiedad marca -
        <code>carro['marca'] = "Alfa Romeo"</code> Para acceder a la marca hacemos lo siguiente:
        <code>carro[marca]</code>
      </li>
      <li><b>Con la notacion punto .</b> - funciona igual que los brackets ya cuando tenemos un objeto declarado, para agregar una propiedad al objeto carro:
        <code>carro.marca = 'Tesla'</code> Para conocer el valor de la propiedad marca del objeto carro:
        <code>carro.marca</code>
      </li>
    </ul>
    <p>También podemos crerar objetos dentro de objetos de la misma usando el mismo principio</p>
    <code>vehiculo.carro.marca = 'Audi'</code>
    <p>Y accedemos de la misma forma:</p>
    <code>vehiculo.carro.marca</code>
  </section>
  <section>
    <h2>Objects and Object Literals</h2>
    <p>Cuando hablamos de objetos anteriormente nos referimos la forma de crear objetos mediante <code>new Object()</code> y mediante <code>{ }</code> bueno, en realidad el uso de los corchetes es simplemente un atajo para hacer lo mismo y se le llama <b>Object Literal</b>      y como vimos también podemos inicializarlo al mismo tiempo agregandole propiedades:</p>
    <img class="img_custom" src="./media/object_literal_one.png" alt="">
    <p></p>
  </section>
  <section>
    <h2>FRAMEWORK ASIDE: Faking Namespaces</h2>
    <p><b>Namespace:</b> A container for variables and functions, typically to keep variables and functions with the same name separate.</p>
    <p>Los namespaces en los lenguajes de programación se refieren a un container que contiene un grupo único de identificadores y simbolos, en JS no los tenemos pero los podemos emular con el uso de objetos. <br> Por ejemplo queremos hacer uso de una variable
      que tenga un mismo nombre para diversos objetos, como lo vimos ahora con el objeto carro, es muy probable que queramos tener varios carros pero cada uno con diferentes caracteristicas aunque mismas propiedades (marca, no de puertas, etc):
    </p>
    <img class="img_custom" src="./media/namespace.png" alt="">
    <p>De esta forma podemos tener el mismo nombre de variable que pertenece a un objeto diferente.</p>
  </section>
  <section>
    <h2>JSON and Object Literals</h2>
    <p>Si hemos visto anteriormente la forma en la que se escribe JSON y vemos la forma en que se escribe un Object Literal vamos darnos cuenta que son muy similares:</p>
    <img class="img_custom" src="./media/object_literal_vs_json.png" alt="">
    <p>Cómo vemos son muy parecidos y lo que cambia son las comillas en los nombres de las propiedades. JSON es un formato muy util para compartir información y JS por medio de un par de funciones nos permite pasar la información de JSON a Object Literal
      y viceversa.</p>
    <p><b>JSON.stringify</b> nos permite pasar de Object literal a JSON:</p>
    <img class="img_custom" src="./media/stringify.png" alt="">
    <p><b>JSON.parse</b> nos permite pasar de JSON a Object Literal:</p>
    <img class="img_custom" src="./media/jsonParse.png" alt="">
  </section>
  <section>
    <h2>Las Funciones son Objetos!</h2>
    <p></p>
  </section>
  <section>
    <h2>CONCEPTUAL ASIDE: By Value vs by Reference</h2>
    <p>Este es un concepto que debemos tener claro. Cuando asignamos a una variable un <b>valor primitivo</b> como un numero on un string, se asigna un espacio en la memoria que contiene ese valor y una dirección que permite que la variable apunte a ese
      valor <code>a = 3;</code>. Si asignamos esa variable a otra variable <code>b = a;</code> como el valor de <b>a</b> es un primitivo, entonces, se asignará un nuevo espacio en memoria para <b>b</b>que contendrá una dirección diferente que apunte a
      su valor, en resumen en memoria habrá en un comienzo y de acuerdo a nuestro ejemplo una variable <b>a</b> y otra <b>b</b> y cada una apuntará a un valor <b>3</b> completamente diferente e independiente ubicados en una dirección en la memoria completamente
      distint.
    </p>
    <img class="img_custom" src="./media/by_value.png" alt="">
    <p>Esto lo podemos probar de la siguiente manera:</p>
    <img src="./media/byValue_test.png" alt="">
    <p>Aunque <b>b</b> haya sido declarada con el valor de <b>a</b> aunque cambiemos el valor de <b>a</b> el valor de <b>b</b> no cambia.</p>
    <p>Con los Objetos pasa algo distinto, si al objeto <b>c</b> le asignamos el objeto <b>d</b> entonces cuando modifiquemos (también se dice <b>mutar</b> en programación) el objeto <b>c</b>, este cambio también se verá reflejado en el objeto <b>d</b>,
      esto sucede porque a diferencia de lo que pasa con las valores primitivo, en los objetos se crea una <b>Referencia</b> al objeto y NO se crea un objeto nuevo como pasa con los primitivos. Osea que tenemos dos variables que apuntan a una misma direcció
      en la memoria.</p>
    <img src="./media/by_reference.png" alt="">
    <p>Lo probamos con el siguiente ejemplo:</p>
    <img src="./media/byReference_test.png" alt="">
    <p>Aunque cambiamos solamente el objeto <b>c</b> vemos que el valor de la propiedad país cambió en los dos objetos, el mismo principio aplica así pasemo el objeto como un parametro dentro de una función</p>
    <img src="./media/byReferenceFunc.png" alt="">
    <p><b>Importante!</b> el simbolo asignación o igual (=) es el que define si un elemento se crea o no en la memoria, en caso de que el Objeto asignado no se encuentre ya en la memoria, entonces será creado en una nueva ubicación, hay que tener esto claro
      poque si por ejemplo tenemos:</p>
    <img src="./media/objetoAsignarNuevo.png" alt="">
    <p>A pesar de que en un inicio las dos variables apuntaban a un mismo objeto, al una de las variables ser asignada a un objeto distinto, este nuevo objeto es creado en memoria y solo la variable al que ha sido asignado apuntará a su ubicació en memoria.</p>
  </section>
  <section>
    <h2>Objects, functions and 'this'</h2>
    <p>Seguramente hemos visto el uso de <b>this</b> en algún código o lo hemos usado nosotros mismos, pues bueno, seguramente lo vamos a ver muchas veces mas porque se usa con bastante frecuencia, pero bueno, que es <b>this</b>?</p>
    <p>Generalmente se piensa que <b>this</b> hace referencia al contexto desde donde se invoca como una función o un objeto, pues bueno si aún lo creemos así debo decirles que NO es correcto, pues <b>this</b> hace solamente referencia al contexo principal
      de un Objeto y no de una función, ya sé que dijimos que las funciones son objetos pero son objetos especiales, son objetos de primera clase que tienen 'poderes' especiales por decirlo de alguna manera. En resumen, <b>THIS hace referencia al primer nivel del contexto de un Objeto (no funciones)</b>      lo demostramos de la siguiente forma:</p>
    <p>Mostremos en la console en el contexto global el valor de <b>this</b>:</p>
    <img src="./media/this_one.png" alt="">
    <p>Nos devuelve el contenido del contexto global que es Window</p>
    <p>Ahora dentro de una función mostremos en consola el valor de <b>this</b>:</p>
    <img src="./media/this_two.png" alt="">
    <p>Seguimos viendo el contenido del objeto global Window a pesar de que estamos dentro de una función.</p>
    <p>Ahora, dentro de un Objeto creemos un metodo que imprima en consola el valor de <b>this</b>:</p>
    <img src="./media/this_three.png" alt="">
    <p>Ahora vemos que el valor mostrado en la consola es el objeto dentro del que se encuentra el método y NO el contexo global, esto nos demuestra que <b>this</b> lo podemos usar principalmente dentro de los objetos si es que queremos referirnos al contenido
      de ese objeto de alguna manera, en nuestro ejemplo podemos cambiar la marca de nuestro carro refiriendonos a <b>this</b>:</p>
    <img src="./media/this_four.png" alt="">
    <p><b>Importante!</b> que pasa si dentro de un método tenemos otra función que busca hacer uso del contenido del objeto mediante <b>this</b>? Lo primero que pensamo de acuerdo a lo que vimos es que <b>this</b> dentro de un objeto hace referencia al objeto
      en el que se encuentra, eso lo pensamos muchos y a lo mejor no estaría mal que fuera así, de hecho seríá hasta lógico pero <b>NO ES ASÍ</b> cuando creamos una función dentro de un método, y esta función hace uso de <b>this</b> el contexto al que
      se hace referencia es de nuevo el contexto <b>global</b>:</p>
    <img src="./media/this_five.png" alt="">
    <p>En el ejemplo anterior vemos como al tratar de imprimir en consola el contenido de <b>this</b> mediante una función que se encuentra dentro de un método lo que muestra la consola es el contenido del contexto global o Window. Una solución común para
      estos casos es crear una variable dentro del Objeto que haga referencia a <b>this</b> esta variable es muchas veces llamada <b>self</b>.</p>
    <h3>self</h3>
    <p>Esta es una variable que se crea dentro del objeto y que resuelve el comportamiento de <b>this</b> dentro de funciones creadas dentro de los método. Cómo ya vimos antes, cuando declaramos una variable y le asignamos un objeto, lo que hace el engine
      es crear una referencia hacia el objeto, por lo tanto podemos hacer <code>self = this</code> aquí un ejemplo:</p>
    <img src="./media/this_six.png" alt="">
    <p>Ahora vemos que la referencia del objeto se ha mantenido y que el objeto impreso en la consola es el mismo objeto en el que se encuentra la función.</p>
  </section>
  <section>
    <h2>ARRAYS: Collections of anything</h2>
    <p>En JS a diferencia de otros lenguajes de programación, podemos poner lo que queramos en un array y combinarlo como queramos, podemos tener en un mismo array <b>objetos, funciones, primitivos</b> lo que queramos, por ejemplo:</p>
    <img src="./media/array_one.png" alt="">
    <p>Tenemos un array que contiene un numero, una función y un objeto y esto es perfectamente válido porque es permitido por el engine de JS. Además podemos hacer uso de los elementos de los arrays o colecciones como mejor nos parezca, por ejemplo podemos
      usar en este caso la función y el contenido del objeto para imprimir algo en la consola:</p>
    <img src="./media/array_two.png" alt="">
  </section>
  <section>
    <h2>'arguments' and SPREAD</h2>
    <p>Argumentos son aquellos valores o parámetros que le pasamos a una función con el fin de que de alguna forma los procese, por ejemplo:</p>
    <pre><code>
      function mifuncion(argumentos){
        //dentro de la función hago uso de los argumentos
      }
    </code></pre>
    <p>>Es probable que otros lenguajes de programación nos devuelvan errores cuando la función invocada no contiene todos los argumentos que en un inicio fueron declarados con la función, JS no nos devuelve ningún error, lo que si va devolver es el valor
      'undefined' pues la variable fue declarada pero nunca asignada.</p>
    <p>JS contiene dentro de las funciones una variable que se llama <b>arguments</b> y que lo que hace es devolver el valor de los argumentos pasados a la función en una <em>especie de array</em> que no es en realidad un array porque no cotiene los métodos
      que contiene un array como pop, unshift, solo tiene el método <em>length</em> que nos devuelve el largo del array y bueno también podemos devolver el contenido de acuerdo a su ubicación dentro del array e.g: <code>array[2]</code>.</p>
    <p>Aquí hacemos uso de la variable <b>arguments:</b></p>
    <pre><code>
      function myCasa(cuartos, banos, jardines){
        console.log('Mi casa tiene '+banos+' baños '+cuartos+' cuartos y '+jardines+' jardines');
        console.log(arguments);
      }

      myCasa(3, 2, 2)
    </code></pre>
    <p>Ahora corremos en consola:</p>
    <img src="./media/arguments_one.png" alt="">
    <p>Parece ser que <em>arguments</em> va a dejarse a un lado en un futuro y se usarán otros métodos que son parte de ES6.</p>
  </section>
  <section>
    <h2>FRAMEWORK ASIDE: Function Overloading</h2>
    <p>En JS no hay function overloading cómo en otros lenguajes</p>
  </section>
  <section>
    <h2>CONCEPTUAL ASIDE: Syntax Parsers</h2>
    <p></p>
  </section>
  <section>
    <h2>DANGEROUS ASIDE: Automatics Semicolon Insertion</h2>
    <p>El Engine de JS va analizando caractér por caractér todo el syntax del código que escribimos y de acuerdo a lo que va viendo va tomando decisiones para ejecutar tareas, pues bueno, dentro de las acciones que toma el Engine es la de agregar automaticamente
      los punto y coma ; (semicolon en inglés) faltantes en nuestro código lo que hace que de alguna manera no sea obligatorio escribirlos y generalmente nuestro código funciona como esperamos. Pero esto no siempre sucede y es probable que el Engine nos
      inserte un punto y coma en donde no queremos y que al final el resultado que esperamos de nuestro programa, por esto es importante tener buenos habitos al momento de escribir código.</p>
    <p>Veamos el ejemplo siguiente:</p>
    <pre><code>
      function juego(){
        //nuestro código
        return    //pasamos a la linea de abajo
        {
          personaje : 'Zelda'
        }
      };
      console.log(juego());

    </code></pre>
    <p>Viendo el código anterior seguramente pensemos que al ejecutar el código vamos a ver en la consola el valor del objeto que debe ser devuelto por la función <code>{personaje : 'Zelda'}</code> pero lo corremos y vemos lo siguiente: </p>
    <img src="./media/semicolon_insertion_one.png" alt="">
    <p>Nos devuelve <b>undefined</b> pero por que? pues bueno, este es el resultado de la inserción automatica de punto y coma del engine, al ver que seguido del método <code>return</code> venía un retorno de carro (carriage return en ingles) o Enter para
      pasar a la linea de abajo, pues el <em>Engine</em> asumió que debía insertar un punto y coma por lo tanto la función no devolvió nada porque terminó en <code>return;</code> por esta razón es mejor siempre evitar cambios de linea innecesarios y escribir
      los puntos y comas así no sea del todo obligatorio, nos evitamos problemas y perder muchisimo tiempo buscando errores en nuesctro código que como estos pueden ser muy dificiles de encontrar.</p>
    <p>Ahora probemos la siguiente función y vemos como SI nos devuelve lo que estamos esperando:</p>
    <pre><code>
      function juego(){
          //nuestro código
          return { //continuamos escribiendo sobre la misma linea
            personaje : 'Zelda'
          };
      }
      console.log(juego());
    </code></pre>
  </section>
  <section>
    <h2>FRAMEWORK ASIDE: Whitespace</h2>

  </section>
  <section>
    <h2>Immediately Invoked Function Expressions (IIFE)</h2>
    <p>Son funciones que como su nombre lo dice se invocan de inmediato, osea que no tenemos que invocarlas en una linea aparte. Generalmente cuando tenemos una función hacemos lo siguiente:</p>
    <pre><code>
      //Function expression
        function saludar(nombre){
          console.log('Hola ' + nombre +' cómo estás?')
        }
        saludar('Hector') //invocamos la función

      //Function declaration
        var saludar = function(nombre){
          console.log('Hola ' + nombre +' cómo estás?')
        }
        saludar('Juan'); //Invocamos la función
    </code></pre>
    <p>Cómo sabemos la única forma de que estás funciones sean ejecutadas es invocandolas después de haberlas declarado en una linea aparte y para invocarlas usamos el nombre y los parentesis e.g. <code>saludar()</code>, las <b>IIFE</b> son funciones que
      básicamente se invocan a ellas mismas al momento de ser declaradas, veamos el siguiente ejemplo:</p>
    <pre><code>
      var nombre = function (nombre){
        return nombre;
      }('Juan') // Agregamos los parentesis al final de la función para que se invoque de inmediato y le podemos pasar argumentos si queremos

      var saludar = function (){
        console.log('Hola ' + nombre + ' cómo estás?') //solo hacemos referencia al nombre de la funcione sin necesidad de invocarla
      }

      saludar()
    </code></pre>
    <p>Al ejecutarse de inmediato ya no tenemos que invocarla de nuevo sino que solo usamos su nombre pues ya en este momento se ha ejecutado y el valor de función <em>nombre</em> para nuestro ejemplo es un <em>string</em>.</p>
    <p>También simplemente podemos crear una función que sin necesaidad de ni siquiera hacer referencia a su nombre podemos hacer que se ejecute tan pronto como sea leída por el engine, lo hacemos de la siguiente forma:</p>
    <pre><code>
      (function(nombre){  //Iniciamos la función con un parentesis
        var saludar = 'Hola '+ nombre;
        console.log(saludar + ' te saludo desde adentro de la IIFE');
      }('Carolina')); //También le podemos pasar argumentos si queremos

      //O le podemos pasr argumentos que se encuentren disponibles al momento de ser invocadas

      var visitante = 'Adriana'; //Variable disponible

      (function(nombre){  //Iniciamos la función con un parentesis
        var saludar = 'Hola '+ nombre;
        console.log(saludar + ' te saludo desde adentro de la IIFE');
      }(visitante);  //pasamos la variable
    </code></pre>
  </section>
  <section>
    <h2>FRAMEWORK ASIDE: IIFEs and Safe Code</h2>
    <p>Anteriormente vimos que cuando creabamos una función también se creaba un nuevo contexto de ejecución (Execution Context) y que este contexto de ejecución es como un ambiente único que puede hacer uso de lo que se encuentre afuera suyo pero que lo
      que se declara dentro solo está disponible dentro de su mismo contexto de ejecución o en funciones que se declaren adentro, pues bueno, teniendo esto claro es bueno tener en cuenta que las IIFEs nos sirven también para crear contextos de ejecución
      que a lo mejor no queremos que contaminen o que compartan información con contextos externos, así pues cuando declaramos variables dentro de las IIFEs estas solo están disponibles dentro de ellas./</p>
  </section>
  <section>
    <h2>UNDERSTANDING CLOSURES 1</h2>
    <p>Siempre entender closures toma tiempo pues es una funcionalidad de JS que puede llegar algo abstranca y que lleva un poco al extremo los conceptos que hemos analizado hasta el momento pero el proceso que hemos llevado nos da las bases suficientes
      para entender mas facilmente lo que es un <b>Closure</b>.</p>
    <p>Lo vamos a ver inicialmente con un ejemlpo:</p>
    <pre><code>
        function saludo(greet){
          return function(name){
            console.log(greet + ' ' + name);
          }
        }

        var diHola = saludo('Hola');
        diHola('Juan');
      </code></pre>
    <p>Aquí vemos que lo que hacemos es devolver una función cómo resultado de otra función, pero ahora enfoquemonos en lo que sucede:</p>
    <ol>
      <li>Asignamos el resultado de la función <code>saludo('Hola')</code> a la variable <code>diHola</code> osea que la función <em>saludo</em> ya ha sido invocada creando la variable <em>greet</em> que quedó con el valor pasado a la función que en este
        caso es <em>Hola</em> y ha devuelto una función que está esperando a ser invocada y que espera que se le pase el argumento <em>name</em>.</li>
      <li>Invocamos la función devuelta que ahora tiene el nombre de <em>diHola</em> con el valor de <em>Juan</em> para nuestro ejemplo <code>diHola('Juan')</code>, cuando corremos este código en consola vemos lo siguiente:</li>
      <img src="./media/closures_one.png" alt="">
    </ol>
    <p>Si lo pensamos bien, <b>cómo hace la función devuelta para recordar el valor de la variable <em>greet</em> si es que esa función ya había sido invocada y por lo tanto su contexto de ejecución había 'desaparecido'?</b> Lo que sucede es que a pesar
      de que es contexto de ejecución de ejecución haya desparecido recolectado por el <em>garbage collector</em>, la memoria que fue usada para crear ese contexto de ejecución <b>sigue existiendo</b> y por lo tanto la referencia a esa variables que fueron
      creadas en ese contexto de ejecución puede seguir siendo utilizadas, a pesar de que un contexto de ejecución desaparezca del <em>execution stack</em> su variables pueden seguir siendo referenciadas desde otros contextos que se encuentran de de ese
      contexto que desapareció.</p>
    <img src="./media/closures_two.png" alt="">
    <p>En definitiva un closure es el <b>encapsulamiento de los entornos a los que de todas maneras hiciera referencia aunque esos contextos que contenían las variables ya no existan</b>. Esto no es algo que podamos generar nosotros o alterar, es algo con
      lo que JS viene y de lo que podemos sacar provecho, esos entornos externos seguiran funcionando y el <em>Engine</em> se encargará de que sea el código que corramos, las variables a las que se supone que debe tener acceso sigan existiendo, <b>basicamente mantiene el contexto intacto</b>.</p>


  </section>
  <section>
    <h2>UNDERSTANDING CLOSURES 2</h2>
    <p>Aquí vamos a tener un ejemplo que seguramente va a parecer un poco mas complicado de entender pero que al final segurmanre nos va a permitir aún mejor lo que se puede lograr con los closures</p>
    <pre><code>
      function buildFunctions(){
        var arr = [] //creramos un array - nada extraño hasta ahora

        for (var i = 0; i < 3; i++){ //un for loop que funciona mientras i sea menor que 3
          arr.push( //pasamos al array 3 diferentes funciones que van a mostrar en consola el valor de 1
            function(){
              console.log(i)
            }
          )
        }
        return arr;
      }

      var fs = buildFunctions();

      fs[0]();
      fs[1]();
      fs[2]();
    </code></pre>
    <p>Como vemos es una función que adentro tiene un for loop y ese for loop debe ir empujando dentro de unr array las funciones que cuando sean invocadas van a <b>imprimir el valor de <em>i</em></b> esto lo resaltamos porque es importante tenerlo claro.
      Viendolo de esta manera con que nos deberíamos encontrar? Si cuando <em>i = 0;</em> el loop empuja una función dentro del array, y cuando <em>i = 1;</em> y también cuando <em>i = 2;</em> y como ya sabemos cada una de esas funciones va a mostrar
      en consola el valor de <em>i</em>? Que valores van a ser realmente logueados? Es posible que nos vayamos a sorprender:</p>
    <img src="./media/closures_three.png" alt="">
    <p>Es probable que esperaramos ver <b>1, 2, y 3</b> logueados en la consola pero no, en cambio vemos <b>3, 3, 3</b> por que pasó esto? pues bueno, en este caso debemos tener en cuenta el momento en que las funciones son invocadas y lo que ha pasado con
      las variables que están siendo referenciadas en ellas.</p>
    <p>En este ejemplo pasó lo siguiente:</p>
    <ol>
      <li>La variable <em>fs</em> se declaró con la invocació de la función <em>buildFunctions</em> y por lo tanto el for loop fue ejecutado</li>
      <li>Dentro del <em>for loop</em> se declaró la variable <em>i</em> esta variable tuvo primero el valor de <b>0</b> y la primera función fue empujada al array, después tuvo el valor de <b>1</b> y otra nueva función fue empujada al array, después tuvo
        el valor de <b>2</b> y otra función pasó al array, finalmente tuvo el valor de <b>3</b> y como la condición fue negativa el <b>for loop terminó</b> y la variable <b>i quedó con un valor de 3</b></li>
      <li>Cada una de estas funciones hace referencia a <em>i</em> que es la variable declarada en el for loop</li>
      <li>Después las funciones que se encuentran dentro del array son invocadas y loguean el valor de <em>i</em> en la consola</li>
    </ol>
    <p>Recordemos que el for loop se ha ejecutado de primero al momento en que la variable <em>fs</em> fue declarada y para que este loop se detuviera, la condición tuvo que ser falsa y esto solo sucedió cuando el valor de <b>i fue igual a 3</b> en este
      momento el contexto de ejecución desapareció pero las variables siguieron en la memoria y aún se podía hacer referencia a ellas, y las otras funciones fueron invocadas mas adelante</p>
    <p>Con <b>ES6</b> se creó una nuevo forma de solucionar esto en caso de que lo queramos evitar y es mediante el uso de <em>let</em>. <em>let</em> es una nueva forma de declarar variables y lo que hace es crear un scope de bloque, en este caso lo que
      hace es crear un scope diferente para cada variable lo que permite que cada vez que se cree no sea modificada por la asignació siguiente:</p>
    <pre><code>
      function buildFunctions(){
        var arr = [] //creramos un array - nada extraño hasta ahora

        for (var i = 0; i < 3; i++){
          let j = i; //Se crea un scope diferente cada vez y cada uno de estos scopes contiene una variable j
          arr.push(
            function(){
              console.log(j)
            }
          )
        }
        return arr;
      }

      var fs = buildFunctions();

      fs[0]();
      fs[1]();
      fs[2]();
    </code></pre>
    <p>También hay otra forma de hacerlo aún usando <b>ES6</b> y es creando un nuevo contexto de ejecución cada vez que la función sea empujada al array, de esta forma se estaría apuntando cada vez a un contexto diferente que contiene un valor de la variable
      diferente:
    </p>
    function buildFunctions(){ var arr = [] //creramos un array - nada extraño hasta ahora for (var i = 0; i
    < 3; i++){ arr.push( (function(j){ return function(){ console.log(j) } }(i)) ) } return arr; } var fs=b uildFunctions(); fs[0](); fs[1](); fs[2](); </section>
      <section>
        <h2>FRAMEWORK ASIDE: Function Factory</h2>
        <p>Ahora que tenemos un poco mas claro lo que son los closures, podemos entonces aprovechar su existencia para en este ejemplo crear una fabrica de funciones. Lo que vamos a hacer es crear una función que va a devolver otras funciones que dependerán
          del parametro que se pase al momento de invocar la función contendera o externa por decirlo de alguna manera.</p>
        <pre><code>
      function fabricarCarro(marca){
        return function(color, velocidad){
            if(marca === 'Ferrari'){
              console.log('Quiero un carro '+ color + ' y que ande ' + velocidad)
            }
            if(marca === 'Bugatti'){
              console.log('Quiero un carro ' + color + ' y que ande ' + velocidad)
            }
        }
      }

      var miFerrari = fabricarCarro('Ferrari'); //Invocamos la función una vez en donde se declara la variable con el valor 'Ferrari'
      var miBugatti = fabricarCarro('Bugatti'); //Invocamos la función de nuevo en donde se declara la variable con el valor 'Bugatti'

      miFerrari('rojo', 'rapdisimo!')
      miBugatti('azul', 'mas rapido!')
    </code></pre>
        <p>En el momento en que declaramos la variable <b>miFerrari</b> la primera función es invocada, se crea un contexto de ejecución y la varible 'marca' es declarada con el valor que le pasamos, en este caso 'Ferrari', cómo la función ya se ejecutó
          entonces el contexto de ejecucíon desaparece pero sus variables siguen en memoria y aún pueden ser referenciadas por las funciones internas.</p>
        <p>Declaramos la segunda variable <b>miBugatti</b> con la declaración de la misma función y le pasamos un argumento que para esta es 'Bugatti', se crea un contexto de ejecución pero este a pesar de que es la misma función, es diferente y se encuentra
          en una dirección diferente en la memoriam este contexto contiene la variable, el contexto desaparece pero la variable sigue estando al alcance de las funciones internas.</p>
        <p>Al final lo que hacemos es pasar argumentos a las variables que en realidad son funciones y vemos que en la consola se loguean los comentarios dependiendo de cual fue la función que invcamos.</p>
      </section>
      <section>
        <h2>Closures and Callbacks</h2>
        <p>Si hemos antes usado JS seguramente hemos también hecho uso de closures y callbacks a lo mejor sin darnos cuenta pero el hecho es que se utilizan con bastante frecuencia, por ejemlpo cuando usamos <b>setTimeout</b>:</p>
        <pre><code>
      function pasarTiempo(){
        var tiempo = 'Han pasado tres segundos';
      setTimeout(function(){
        console.log(tiempo)

      }, 3000)
    }
    pasarTiempo();
    </code></pre>
        <p>Ahora seguramente lo vemos un poco mas claro, acá lo que está pasando es que el método setTimeout espera 3 segundos para ejecutarse después de que se haya invocado la función que lo contiene, al ejecutarse el <em>setTimeout</em> todavía puede
          hacer referencia a las variables qexternas aunque ya la función hubiese sifo invocada tres segundo atrás, un perfecto ejemplo de Closures.</p>
        <p>Por otro lado tenemos los <b>callbacks</b> que en resumen son <b><em>Una función a la que le pasamos como argumento otra función para que sea ejecutada cuando la primera funcioón haya terminado</em></b>:</p>
        <pre><code>
      function llamarCuandoTermine(funcionCallback){
        var a = 'Un valor cualquiera';
        var b = 'Otro valor cualquiera';

        var c = a + b;

        funcionCallback();
      }

      llamarCuandoTermine(function(){
        console.log('Terminé')
      })

      llamarCuandoTermine(function(){
        console.log('Yo también terminé')
      })
    </code></pre>
      </section>
      <section>
        <h2>call(), apply(), and bind()</h2>
        <p>Estos son algunos métodos que a lo mejor no conocíamos pero que son bastante útiles y nos podrían permitir reutilizar nuestro código de una manera bastante eficiente, comencemos con <b>call</b>:</p>
        <h3>bind()</h3>
        <p><em>bind()</em> es un método que hace parte de todas las funciones, todas las funciones tienen acceso a estos tres métodos (call, apply y bind). Lo que en resumen <b>bind()</b> nos permite es hacer una copia de la función, asignarle un nuevo contexto
          y pasarle argumentos que van a preceder los que sean pasados cuando la función es invocada. Un poco confuso? veamoslo con un ejemplo:</p>
        <pre><code>
      //Creemos un objeto cualquiera
      var avion = {
        asientos: 15,
        velocidadMax: '700Km/h',
        loguearConsola : function(){
            return 'Tengo un avión con ' + this.asientos + ' asientos y que vuela a ' + this.velocidadMax;
        }
      }

      var otroMensaje = function (arg1, arg2){
        console.log(this.loguearConsola());//Se ve un poco raro, estos 'this' en este lugar apunta al objeto global que no contiene el método 'loguearConsola'
        console.log('Mi hermano tiene ' + arg1 + ' años y mi hermana ' + arg2);
      }

      var darPoderesFuncion = otroMensaje.bind(avion);
      darPoderesFuncion(32, 22);
      //También podemos establecer valores que van a preceder a los de la funcion, mi hermano va a tener siempre 15:
      var darPoderesFuncion = otroMensaje.bind(avion, 15);
      darPoderesFuncion(32, 22); //Aunque le paso el valor de 32, 15 quedó como el primer valor, ahora 32 es el segundo y 22 el tercero
    </code></pre>
        <h3>call()</h3>
        <p>Estos tres métodos hacen todos cosas por el estilo, en este caso lo que <b>call</b> hace, call hace básicamente lo mismo que <b>bind</b> hace a diferencia que <b>call</b> invoca la función de inmediato, veamos:</p>
        <pre><code>
      //Tenemos todo igual que antes
      var avion = {
        asientos: 15,
        velocidadMax: '700Km/h',
        loguearConsola : function(){
            return 'Tengo un avión con ' + this.asientos + ' asientos y que vuela a ' + this.velocidadMax;
        }
      }

      var otroMensaje = function (arg1, arg2){
        console.log(this.loguearConsola());
        console.log('Mi hermano tiene ' + arg1 + ' años y mi hermana ' + arg2);
      }

      otroMensaje.call(avion, 18, 15)
    </code></pre>
        <p>Al correr este código veremos que la función se ejecutó de inmediato, por lo tanto <b>call</b> no hace una copia como si lo hace bind, call invoca la función. También cambiamos con el primer argumento el lugar a donde apunta <em>this</em> y le
          podemos pasar los argumentos que queramos.</p>
        <h3>apply()</h3>
        <p>Lo mismo que <b>call</b> con la diferencia que los argumento se pasan como un array no en comas, veamos:</p>
        <pre><code>
      //Tenemos todo igual que antes
      var avion = {
        asientos: 15,
        velocidadMax: '700Km/h',
        loguearConsola : function(){
            return 'Tengo un avión con ' + this.asientos + ' asientos y que vuela a ' + this.velocidadMax;
        }
      }

      var otroMensaje = function (arg1, arg2){
        console.log(this.loguearConsola());
        console.log('Mi hermano tiene ' + arg1 + ' años y mi hermana ' + arg2);
      }
      otroMensaje.apply(avion, [15, 32])
    </code></pre>
        <h3>Usos Prácticos de estos métodos</h3>
        <h4>Function Borrowing</h4>
        <p>Estos métodos pueden llegar a ser muy útiles si sabemos en que casos utilizarlos, por ejemplo, podemos usar tanto <b>call</b> como <b>apply</b> para algo que se llama function borrowing o prestamo de funciones, lo que hacemos es de alguna forma
          pedir prestada la función de un objeto para usarla en mi objeto:</p>
        <pre><code>
      var carro = {
        distancia: 270,
        tiempo: 4,
        velocidad: function(){
          console.log('Mi carro va a ' + this.distancia/this.tiempo + ' kilometros por hora');
        }
      }

      var bus = {
        distancia: 350,
        tiempo: 6,
      }

      //Tengo un objeto con el método que me da la velocidad pero en el otro no lo tengo y quisera usarla

      carro.velocidad.call(bus, 500, 9); //carro le presta la funciona velocidad a bus
    </code></pre>
        <h4>Function Currying</h4>
        <p>Es crear una copia de una función pero con algunos parametros predefinidos, veamoslo mas claro:</p>
        <pre><code>
      function manejar(a, b){
        console.log('En ' + a + ' se maneja al lado ' + b + ' de la vía' )
      }

      //y Ahora queremos usar la misma funcion pero para casos diferentes:
      //Estos argumentos que pasamos en el call son los que persisten:
      var manejarLatinoamerica = manejar.bind(this, 'Colombia', 'Derecho')
      //Podemos pasar otros argumentos que no van a cambiar en nada porque la función solo recibe dos y ya los pasamos antes (colombia, izquierdo)
      manejarLatinoamerica('hola', 'hey');

      //O podemos pasar solo un argumento al momento del call o podemos no pasar nada y pasarlos después, hay que tener claro que si pasamos solo uno al comienzo y la función pide dos, el que se pase después irá de segundo:
      var manejarInglaterra = manejar.bind(this, 'Inglaterra', )
      manejarLatinoamerica('Izquierdo');

      //En este caso que lo que usamos es una función, pasamos solo 'this' como el nuevo contexto porque en realidad no importa pues como sabemos 'this' en una función apunta al objeto global
    </code></pre>
      </section>
      <section>
        <h2>Functional Programming</h2>
        <p></p>
      </section>
      <section>
        <h2>Functional Programming 2</h2>
        <p>Underscore aplica mucho de functional programming, podemos entar a la página underscorejs.org y en la esquina superior izquierda hay un vinculo <a href="https://underscorejs.org/docs/underscore.html">Annotated Source</a> que muestra el código
          y nos da una breve explicación de que hacen las funciones, immportante revisarlo.</p>
      </section>
      <section>
        <h2>Classical vs Prototypal Inheritance</h2>
        <p>Primero definamos lo que es herencia: <em>'Un objeto tiene acceso a las propiedades y métodos de otro objeto'</em></p>
        <p>Classical Inheritance:</p>
        <ul>
          <li>Muy larga de definir, tenemos que escribir mucho código</li>
        </ul>
        <p>Prototypal Inheritance</p>
        <ul>
          <li>Es flexible</li>
          <li>Se puede extender</li>
          <li>Facil de entender</li>
        </ul>
      </section>
      <section>
        <h2>Understanding the PROTOTYPE</h2>
        <p>Prototype es un objeto dentro de un objeto</p>
        <p>Cada objeto puede tener su propio <em>Prototype</em> por lo tanto un <em>Prototype</em> puede contener un <em>Prototype</em></p>
        <p>Si queremos acceder a las propiedades del <em>Prototype</em> nos podemos referir al objeto externo o ancestro mayor</p>
        <img src="./media/proto_one.png" alt="">
        <p><b>Prototype Chain</b> es la cadena de prototypes dentro de prototypes</p>
        <img src="./media/proto_two.png" alt="">
        <p>Podemos hacer que un objeto puede acceder al prototype de otro objeto, esto lo vamos a ver mas adelante.</p>
      </section>
      <section>
        <h2>Everything is an Object (or a primitive)</h2>
        <p>Todo lo que no es un primitive tiene un prototype (objetos, arrays, funciones, etc..) menos el objeto base, veamos</p>
        <p>Primero creemos un objeto, una función y un array</p>
        <pre><code>
        var a = {};
        var b = function(){};
        var c = [];
    </code></pre>
        <p>Ahora desde la consola veamos que contiene el <b>prototype</b> para ver el prototype podemos usar <code>a.__proto__</code>, solo debemos usar <code>__proto__</code> para evr que es lo que contiene el prototype, aunque también lo podemos usar para
          agregar métodos al objeto esto <b>NO</b> se debe hacer, pues afectaría el funcionamiento de la página.</p>
        <img src="./media/proto_three.png" alt="">
        <p>Podemos ver los métodos que siempre tiene un objeto y que podemos utilizar cuando queramos</p>
        <p>Si miramos lo que contiene el <em>prototype</em> de una función:</p>
        <img src="./media/proto_four.png" alt="">
        <p>Ahora lo vamos a ver de una forma diferente pero si después de 'proto' ponemos un punto, nos van a aparecer los métodos que la función contiene por defecto cada vez que se crea una, vemos que entre ellas tenemos <em>call, apply y bind</em> que
          ya vimos anteriormente de lo que se tratan.</p>
        <p>Ahora veamos lo que contiene el <em>prototype</em> de una array</p>
        <img src="./proto_five.png" alt="">
        <p>Ahora vemos las mismas funciones que usamos cuando trabajamos con un array, push, slice, map, forEach, etc.</p>
        <p>Que pasa si entramos al <em>prototype</em> del <em>prototype</em>?</p>
        <img src="./media/proto_six.png" alt="">
        <p>Encontramos los métodos que contiene el objeto base y como sabemos el objeto base no tiene <em>prototype</em> así que no podemos ir mas adentro.</p>
      </section>
      <section>
        <h2>Reflextion and Extend</h2>
        <p><b>REFLECTION: </b>Un Objeto puede verse a si mismo, enlistar y cambiar sus propiedades y métodos.</p>
        <p><b>EXTEND: </b>Es un método de la libreria <b>Underscorejs</b> que usando <b>REFLECTION</b> copia parametros de un objeto a otro, este método es muy común en casi todas las librerias porque es muy util, en <b>Underscore</b> funciona así</p>
        <pre><code>
      //tenenemos varios objetos:
      var objetoUno = {
        propUno : 'Uno';
        propDos : 'Dos'
      }
      var objetoDos = {
        propTres : function(){
          return this.propUno + this.propDos + this.propCuatro;
        }
      }
      var objetoTres = {
        propCuatro : : 'Cuatro'
      }

      _.extend(objetoUno, objetoDos, objetoTres)

      //Se copian las propiedades del objetoDos y objetoTres al objetoUno
    </code></pre>
        <p><b>Importante!</b> ES6 tiene la propiedad <b>extends</b> que crea un <em>prototype</em></p>
      </section>
      <section>
        <h2>Building Objects</h2>
        <h3>Function Constructors y la palabra 'new'</h3>
        <p>Cuando tenemos un objeto es muy probable que queramos crear multiples copias de ese objeto aunque a lo mejor con propiedades de diferentes valores, para lograr esto podemos usar la palabra <b>new</b> cuando usamos la palabra <em>new</em> se crea
          un objeto completamente vacío, primero creemos la <b>función constructora</b> </p>
        <pre><code>
      function Carro(){
          this.marca = 'Tesla';
          this.color = 'Negro';
      }
    </code></pre>
        <p>Ya tenemos nuestra función constructora, ahora queremos crerar una instancia o un objeto que contenga estas propiedades, esto lo hacemos usando la palabra <em>new</em>:</p>
        <pre><code>
      var miCarro = new Carro();
    </code></pre>
        <p>Ya debemos tener un nuevo objeto <em>miCarro</em> veamoslo en la consola</p>
        <img src="./media/constructor_one.png" alt="">
        <p>Ya tenemos una instancia del objeto Carro. Cuando <em>new</em> crea el objeto, se ejecuta la función constructora y los <b>this</b> que se encuentran dentro apuntan a este nuevo objeto creado</p>
        <p>Ahora quiero poder crerar varios objetos pero con valores diferentes, lo que tenemos que hacer es pasarle argumentos a nuestra función constructora:</p>
        <pre><code>
      //Creamos una nueva función constructora
      function Personaje(poder, genero){
        this.poder = poder;
        this.genero = genero
      }
      //Tenemos nuestra función constructora, ahora creemos multiples instancias
      var avispa = new Personaje('aguijon', 'mujer');
      var pantera =  new Personaje ('velocidad', 'hombre')
      //Ahora veamoslos en la consola
      console.log(pantera);
      console.log(avispa);
    </code></pre>
        <img src="./media/constructor_two.png" alt="">
        <p><b>DEFINICIÓN</b> <br> Función Constructora: Es una función normál que es usada para crear objetos. La variable <em>this</em> apunta al nuevo objeto creado y ese objeto es devuelto por la función de forma <b>automatica.</b></p>
        <h3>Function constructors y 'Prototype'</h3>
        <p>Cómo definimos el prototype??</p>
        <p>Posiblemente nunca lo supimos pero las funciones además de contener código y que puede ser invocable con <code>()</code> y la posibilidad de darle nombre o no, pues bueno, también vienen con <em>prototype</em>, el tema es que este es solo usado
          cuando usamos la palabra <em>new</em>, como vimos antes al crear una función constructora usamos la palabra <em>new</em> la cual crea un objeto en vacío y las variables <em>this</em> dentro de la función constructora hacen referencia a ese nuevo
          contexto de ejecución y crean las propiedades que solicitamos. Además de suceder todo esto, al usar la palabra <em>new</em> ese nuevo objeto que se crea va a tener como <em>prototype</em> el de la función constructora, y todos los objetos creados
          a partir de esa misma función constructora van a poder hacer uso de ese mismo prototype. Veamoslo mas claro con un ejemplo:</p>
        <pre><code>
      //Tenemos nuestros mismos personajes que salieron de la misma función constructora
      function Personaje(poder, genero){
        this.poder = poder;
        this.genero = genero
      }
      var avispa = new Personaje('aguijon', 'mujer');
      var pantera =  new Personaje ('velocidad', 'hombre')

      //Ahora creemos un método dentro del prototype de la función constructora

      Personaje.prototype.caracteristicas = function(){
        return 'Este personaje es ' + this.genero + ' y su poder es ' + this.poder;
      }

      //Ahora veamos que pasa si logueamos uno de los personajes
      console.log(pantera)

      //Ahora usemos ese nuevo método al que tenemos acceso
      avispa.caracteristicas();
    </code></pre>
        <p>Si hicimos lo anterior vimos lo siguiente en la consola:</p>
        <img src="./media/proto_seven.png" alt="">
        <p>Esta una habilidad muy interesante que tiene JS pues como vimos podemos agregar lo que queremos dentro del <em>prototype</em> cuando queramos. Generalmente los métodos se crean usando el <em>prototype</em> y no declarandolos dentro de la función
          constructora, de esta forma<b> evitamos crear una función por cada objeto cuando es creado, usando el prototype los objetos hacen referencia a sus métodos pero no se crea una copia nueva cuando el objeto es creado</b> de esta forma evitamos
          ahorramos el uso de memoria.</p>
        <p><b>IMPORTANTE</b> Crear métodos usando prototype</p>
      </section>
      <section>
        <h2>DANGEROUS ASIDE - new and Functions</h2>
        <p>Nos podemos haber preguntado por que cuando creamos una función constructora le ponemos la primera letra mayuscula, pues bueno, esto es con el fin recordarnos a nosotros mismo que esta es una función constructora y que por lo tanto para crear
          una instancia debemos usar la palabra <b>new</b> porque si no la usamos la función será igual invocada pero no tendremos los resultados esperados pues ya sabemos que <em>new</em> hace que sucedan muchas cosas. Si no usamos <em>new</em> cuando
          lo necesitamos vamos a tener muchos errores :(</p>
        <p><b>IMPORTANTE:</b> Siempre comenzar una función constructora con mayuscula</p>
      </section>
      <section>
        <h2>CONCEPTUAL ASIDE: Built-in function constructors</h2>
        <p>Hay varias funciones contructoras que JS ya trae por defecto, por ejemplo podemos usar:</p>
        <pre><code>
      var a = new String;
      var b = new Number;
        </code></pre>
        <p>De esta forma estamos usando funciones constructoras para 'crear' numeros y strings o almenos eso es lo que creemos, como vimos antes los strings y los numeros son primitivos de JS no precisamente objetos y como también vimos antes la palabra
          <em>new</em> crea <b>objetos</b> mmm un poco confuso no? numeros y strings son primitvos pero podemos crear objetos de ellos? bueno, si es poco confuso además que el engine se comporta un poco diferente con estos dos constructores:</p>
        <pre><code>
          //Mostremos lo siguiente en la la consola
          'Andres'.length
          //Y después esto:
          4.toFixed
        </code></pre>
        <p>Si ejecutamos los dos comandos anterior por aparte en la consola nos dimos cuenta que el primoer funcionó muy bien pero el segundo nos dio un error, bueno estos <b>sucede porque el engine trata de forma diferente los números y los strings, miemtras los strings son convertidos inmediatamente en objetos los objetos no lo son, por eso es que podemos usar los métodos de uno pero no los del otro.</b></p>
        <p>Podemos también crear métodos en el prototype de cualquiera de estos objetos y poder utilizar estos métodos cuando queramos, esta es en realidad la forma en que JS funciona y muchos frameworks y librerias sacan provecho de esta funcionalidad:</p>
        <pre><code>
          Number.prototype.positivo = function(){
            return this > 0;
          }
        </code></pre>
        <p>Veamoslo en la consola</p>
        <img src="./media/constructor_three.png" alt="">
        <p>Le creamos una función al prototype de Number y ahora podemos acceder a este método desde cualquier primitivo que sea número</p>

        <h2>DANGEROUS ASIDE: Built inf Function Constructors</h2>
        <p>Cuando usamos las funciones constructoras que vienen incorporadas dentro JS (new Number, new String, new Date etc) debemos tener en cuenta que estamos creando un Objeto y no un primitivo y po lo tanto si quieremos en algún momento hacer comparación
          entre un numbero creado a partir de <code>var numeroCons = new Number(3)</code> y otro numero creado como primitivo <code>var numeroPrimitivo = 3</code> pues vamos a tener problemas porque uno es un objeto y el otro un primitivo y si hacemos:
          <code>numeroCons === numeroPrimitivo</code> pues nos va a dar falso! <b>Importante tenerlo en cuenta</b></p>
        <p><b>IMPORTANTE:</b> Si en algún momento vamos a trabajar con fechas hay un framewrok que se llama <b>moment.js</b> que es de mucha ayuda para trabajar con fechas</p>

        <h2>DANGEROUS ASIDE: Arrays and for..in</h2>
        <p><b>for..in</b> lo usamos para iterar sobre las propiedades de un objeto, por ejemplo:</p>
        <pre><code>
          var miCasa = {
            pisos: 3,
            color: 'verde',
            ventanas: 4
          }

          for(prop in miCasa){
            console.log(prop +':'+miCasa[prop])
          }
        </code></pre>
        <img src="./media/forin_one.png" alt="">
        <p>Funciona muy bien, y en teoria también lo podemos usar con los arrays pues al final son objetos que contiene pares de nombre/valor el nombre siendo el index o posición y el valor, el problema es que si le agregamos algúna otra propiedad al prototype
          del array, esta propiedad va a hacer parte de la iteración, va a ser incluido dentro de los resultados.</p>
      </section>
      <section>
        <h2>Object.create and Prototypal Inheritance</h2>
        <p>Lo que vimos anteriormente acerca de las funciones constructoras es al final una forma en la que JS imitiaba la forma en que las funciones constructoras funcionan en otros lenguajes de programación, en otros lenguajes se crean classes que es el
          'blueprint' o 'plano' desde el cual se producen copias de objetos y esto se hace usando la palabra <em>new</em>. De un tiempo para aca JS ha adoptado su propia forma de construir objetos y que es única para el lenguaje y al final puede ser mas
          facil de entender y de usar.</p>
        <p><b>Pure Prototypal Inheritance - Importante</b></p>
        <p>Veamos de lo que se trata con unos ejemplos:</p>
        <pre><code>
          //Vamos a crear un simple objeto
          var persona ={
            nombre: 'Nombre defecto',
            apellido: 'Apellido defecto',
            saludar: function(){
              return 'Hola soy ' + this.nombre;            }
          }

          //Y ahora vamos a usar Object.create para construir un nuevo objeto

          var Juan = Object.create(persona);
        </code></pre>
        <p>Así es como creamos un objeto usando <b>Object.create</b> veamos que nos muestra la consola:</p>
        <img src="./media/pure_prototypal_one.png" alt="">
        <p><b>Es un objeto Vacio!</b> lo que vemos ahora es un objeto vacío pero que tiene como prototype las propiedades del objeto desde el que fue creado. Para <b>cambiar estas propiedades</b> lo que tenemos que hacer es sobreescribirlas: </p>
        <pre><code>
          //Vamos a crear un simple objeto
          var persona ={
            nombre: 'Nombre defecto',
            apellido: 'Apellido defecto',
            saludar: function(){
              return 'Hola soy ' + this.nombre;            }
          }

          //Y ahora vamos a usar Object.create para construir un nuevo objeto

          var Juan = Object.create(persona);

          //Cambiemos el valor de la propiedad 'nombre'

          Juan.nombre = 'Juan';

          //Ahora usemos el método que tenemos en el prototype

          Juan.saludar();
        </code></pre>
        <p>Vemoslo en consola:</p>
        <img src="./media/pure_prototypal_two.png" alt="">
        <p>Esta es una forma es mucho mas clara y muy facil de usar para cuando queramos construir objetos.</p>
      </section>
      <section>
        <h2>ES6 and CLASSES</h2>
        <p>Ahora en ES6 podemos usar <b>classes</b> aunque en JS las clases no son exactamente lo mismo a lo que son en otros lenguajes de programación, en otros lenguajes las clases son basicamente una plantilla de lo que queremos crear con bases en ellas
          pero no son mas que eso, en JS las classes aunque también funcionan como plantillas también son objetos, una clase es un objeto en JS.</p>
        <p>No mucha gente parece estar de acuredo con la implementación de classes en JS porque como vimos antes con el <b>Pure Prototypal Inheritance</b> JS ya tiene una forma de hacer basicamente lo mismo, pero bueno veamos como se usa:</p>
        <pre><code>
          //Creemos una clase

          class Person{
            constructor(firstname, lastname){
              this.firstname = firstname;
              this.lastname = lastname;
            }

            greet(){
              return 'Hi ' + firstname
            }
          }

          //Ahora creemos un objeto a partir de la class

          var Juan = new Person('Juan', 'Puentes');
        </code></pre>
        <p>De esta forma creamos una instancia del objeto, aquí funciona un poco diferente porque tenemos que definir el <b>prototype</b>, pensemos que queremos que <em>Person</em> sea el <em>prototype</em> pero además queremos que otra clase con otras propiedades
          sea la constructora:</p>
        <pre><code>
          class Piloto extends Person {
            constructor (firstname, lastname){
              super(firstname, alstname);
            }
            greet(){
              return 'Mi nombre es ' + firstname + ' y soy piloto'
            }
          }

          //Usamos 'extend' para crear definir el prototype
          //Usamo 'super' para
        </code></pre>

        <p>Esto es un simple repaso de estas 'nuevas' formas de crear Objetos, la vamos aprofundizar mas adelante</p>
      </section>
      <section>
        <h2>ODDS AND ENDS</h2>
        <h3>STRICT MODE</h3>
        <P><code>'use strict'</code> hace parte de JS y nos permite de alguna forma cometer menos errores porque nos avisa cuando se encuentra con algo extraño como por ejemplo cuando declaramos una variable con un nombre pero cuando la usamos lo hacemos
          con otro nombre que no fue declarado, por ejemplo:</P>
        <pre><code>
          //declaramos que queremos hacer uso del modo estricto

          'use strict'

          var locomotora;
          locomoora = 'super rapida'; //hay un typo, nos falta la T en locomotora
          console.log(locomoora)
        </code></pre>
        <p>En este ejemplo estamos declarando una variable pero usamos una con un nombre distinto y que no fue declarado, veamos que pasa en la consola:</p>
        <img src="./media/use_strict.png" alt="">
        <p>Para saber mas del <b>modo estricto</b> podemos revisar el siguiente vinculo <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Modo_estricto">Modo estricto</a>.</p>
      </section>
      <section>
        <h2>jQuery</h2>
        <h2>Method Chaining</h2>
        <p>Cuando llamamos un método justo después de otro y cada método afecta el objeto padre. <code>obj.methos1().method2()</code> y los dos métodos terminan con las variable 'this' apuntando al 'objeto'</p>
      </section>
      <section>
        <h2>Our Own FRAMEWORK</h2>
        <p></p>
        <h3>Structuring Safe Code</h3>


      </section>


</body>

</html>
